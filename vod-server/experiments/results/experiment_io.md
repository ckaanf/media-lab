#  VOD 스트리밍 서버 IO 효율성 비교 실험 보고서
## [실험 1]: Zero-copy (C++) vs User-space Copy (Java) 간의 Chunk Size 변화에 따른 성능 및 병목 현상 분석

## 1. 실험 환경 및 조건
- **대상**: C++ (sendfile 기반), Java (Standard IO 기반)
- **도구**: k6 (Load Testing), 100 VUs, 30s Duration
- **변수**: Chunk Size (64KB vs 1MB)
- **핵심 가설**:
  - Java는 Chunk Size가 커질수록 User-space 메모리 복사 오버헤드로 인해 **Tail Latency(P95)**가 급격히 증가할 것이다.
  - C++은 Zero-copy 기술을 사용하여 대용량 데이터 전송 시에도 안정적인 지연 시간을 유지할 것이다.

## 2. 실험 결과 요약

| 지표 | Java (64KB) | Java (1MB) | **변화율 (Java)** | C++ (64KB) | C++ (1MB) | **변화율 (C++)** |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| **Avg Latency** | 2.6ms | 4.13ms | **+58.8%** | 0.95ms | 1.61ms | **+69.4%** |
| **P95 Latency** | 3.66ms | **9.38ms** | **+156.3% 🚀** | 2.85ms | **2.7ms** | **-5.3% (안정)** |
| **Throughput** | 68 MB/s | 1.1 GB/s | x16.1 | 69 MB/s | 1.1 GB/s | x15.9 |

## 3. 핵심 분석 및 결과 해석

###  1. Java: User-space Copy 병목 증명
- **현상**: 청크 사이즈가 64KB에서 1MB로 16배 증가할 때, 평균 지연 시간보다 **P95 지연 시간(9.38ms)**의 증가폭이 압도적으로 높음 (+156%).
- **원인**: 1MB 청크를 처리하기 위해 매번 Java Heap에 메모리를 할당하고 커널의 데이터를 유저 공간으로 복사하는 과정에서 CPU 부하 및 메모리 대역폭 점유가 발생함. 특히 상위 5%의 요청이 밀리는 현상이 관찰됨.

###  2. C++: Zero-copy (sendfile)의 우수성
- **현상**: 처리하는 데이터 양이 16배 늘어났음에도 불구하고, **P95 Latency는 2.7ms 수준으로 유지**되거나 오히려 소폭 개선되는 일관성을 보여줌.
- **원인**: `sendfile` 시스템 콜을 사용하여 커널 공간 내에서 데이터가 바로 NIC(네트워크 카드)로 전달됨. 유저 공간의 메모리 복사 과정이 생략되므로 데이터 크기가 커져도 Latency에 미치는 영향이 최소화됨.

###  3. Throughput 대비 Latency 효율
- 두 서버 모두 1.1 GB/s라는 최대 대역폭을 소화하고 있으나, **Java는 응답 지연을 희생하며 처리**하고 있는 반면, **C++은 지연 시간을 일정하게 유지**하며 효율적으로 전송하고 있음이 증명됨.

## 4. 최종 결론
본 실험을 통해 대용량 미디어 데이터를 전송하는 VOD 서비스에서 **User-space 메모리 복사가 성능의 주요 병목점(Bottleneck)**임을 확인하였다. 1MB 이상의 큰 청크를 다룰수록 C++의 Zero-copy 방식이 Java의 일반적인 IO 방식보다 Tail Latency 관리 측면에서 압도적으로 유리하다는 것이 입증되었다.


## [실험 2] 동시 접속자 수(VUs) 변화에 따른 확장성 분석

### 1. 실험 조건
- Chunk Size: 256KB (고정)
- VUs 변화: 100 -> 300 -> 500

### 2. 결과 분석
- **Java (병목 발생)**: 동시 접속자가 증가함에 따라 P95 Latency가 **3.6ms에서 154.9ms로 폭증**. 500 VUs 구간에서 메모리 복사 및 스레드 경합으로 인해 처리량(Req/s) 증가세가 꺾임.
- **C++ (선형 확장)**: 500 VUs에서도 P95 Latency가 **3.8ms**를 유지. Zero-copy 덕분에 CPU가 연산에 집중할 수 있어 처리량이 선형적으로 증가(4,390 Req/s)하며 1.2 GB/s의 네트워크 대역폭을 모두 소화함.

### 3. 결론
고부하 환경(High Concurrency)일수록 Zero-copy의 가치는 커진다. Java의 일반적인 IO 방식은 동시 접속자가 많아질수록 유저 레벨에서의 메모리 복사 오버헤드가 기하급수적으로 누적되어 대규모 서비스 운영에 불리함을 확인하였다.


## [실험 3] Java 성능 최적화: Read/Write vs transferTo (Zero-copy)

### 1. 개요
Java 서버의 병목 원인이 메모리 복사에 있음을 증명하기 위해, 기존 `ResourceRegion` 방식을 `FileChannel.transferTo()` 방식으로 개선하여 동일 조건에서 재테스트함.

### 2. 결과 비교 (500 VUs 기준)
- **기존 방식**: P95 Latency 154.9ms
- **개선 방식 (transferTo)**: P95 Latency **110.9ms** (약 28% 성능 향상)

### 3. 최종 해석
- **복사 비용 제거 효과**: Java에서도 Zero-copy 기술을 적용했을 때 시스템의 전체적인 지연 시간이 크게 개선됨을 확인.
- **잔여 병목 지점**: 메모리 복사를 제거했음에도 C++과 성능 차이가 발생하는 것은 서블릿 컨테이너의 구조적 오버헤드 및 JVM 런타임 비용에 기인한 것으로 분석됨.
- **결론**: 최적의 스트리밍 성능을 위해서는 효율적인 IO 모델(Zero-copy)뿐만 아니라, 가벼운 런타임 환경과 비동기 이벤트 루프 구조가 결합되어야 함.