#  VOD 스트리밍 서버 IO 효율성 비교 실험 보고서
**실험 주제**: Zero-copy (C++) vs User-space Copy (Java) 간의 Chunk Size 변화에 따른 성능 및 병목 현상 분석

## 1. 실험 환경 및 조건
- **대상**: C++ (sendfile 기반), Java (Standard IO 기반)
- **도구**: k6 (Load Testing), 100 VUs, 30s Duration
- **변수**: Chunk Size (64KB vs 1MB)
- **핵심 가설**:
  - Java는 Chunk Size가 커질수록 User-space 메모리 복사 오버헤드로 인해 **Tail Latency(P95)**가 급격히 증가할 것이다.
  - C++은 Zero-copy 기술을 사용하여 대용량 데이터 전송 시에도 안정적인 지연 시간을 유지할 것이다.

## 2. 실험 결과 요약

| 지표 | Java (64KB) | Java (1MB) | **변화율 (Java)** | C++ (64KB) | C++ (1MB) | **변화율 (C++)** |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| **Avg Latency** | 2.6ms | 4.13ms | **+58.8%** | 0.95ms | 1.61ms | **+69.4%** |
| **P95 Latency** | 3.66ms | **9.38ms** | **+156.3% 🚀** | 2.85ms | **2.7ms** | **-5.3% (안정)** |
| **Throughput** | 68 MB/s | 1.1 GB/s | x16.1 | 69 MB/s | 1.1 GB/s | x15.9 |

## 3. 핵심 분석 및 결과 해석

###  1. Java: User-space Copy 병목 증명
- **현상**: 청크 사이즈가 64KB에서 1MB로 16배 증가할 때, 평균 지연 시간보다 **P95 지연 시간(9.38ms)**의 증가폭이 압도적으로 높음 (+156%).
- **원인**: 1MB 청크를 처리하기 위해 매번 Java Heap에 메모리를 할당하고 커널의 데이터를 유저 공간으로 복사하는 과정에서 CPU 부하 및 메모리 대역폭 점유가 발생함. 특히 상위 5%의 요청이 밀리는 현상이 관찰됨.

###  2. C++: Zero-copy (sendfile)의 우수성
- **현상**: 처리하는 데이터 양이 16배 늘어났음에도 불구하고, **P95 Latency는 2.7ms 수준으로 유지**되거나 오히려 소폭 개선되는 일관성을 보여줌.
- **원인**: `sendfile` 시스템 콜을 사용하여 커널 공간 내에서 데이터가 바로 NIC(네트워크 카드)로 전달됨. 유저 공간의 메모리 복사 과정이 생략되므로 데이터 크기가 커져도 Latency에 미치는 영향이 최소화됨.

###  3. Throughput 대비 Latency 효율
- 두 서버 모두 1.1 GB/s라는 최대 대역폭을 소화하고 있으나, **Java는 응답 지연을 희생하며 처리**하고 있는 반면, **C++은 지연 시간을 일정하게 유지**하며 효율적으로 전송하고 있음이 증명됨.

## 4. 최종 결론
본 실험을 통해 대용량 미디어 데이터를 전송하는 VOD 서비스에서 **User-space 메모리 복사가 성능의 주요 병목점(Bottleneck)**임을 확인하였다. 1MB 이상의 큰 청크를 다룰수록 C++의 Zero-copy 방식이 Java의 일반적인 IO 방식보다 Tail Latency 관리 측면에서 압도적으로 유리하다는 것이 입증되었다.